### General Notes

This is a PowerShell cmdlet that is used to query all types of [[Windows Events Log]]s.
- Has the power to retrieve different types of logs and logs generated by both [[Windows Events Log]] technology and [[Event Tracing for Windows (ETW)]] technology.
- Documentation [here](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent?view=powershell-7.5).

> It can retrieve logs from both local and remote computers.

##### Using the `FilterHashtable`

More efficient, here is the syntax. What's inside the curly braces are the parameters and values we are searching for.
```
@{ <name> = <value>; [<name> = <value> ] ...}
```
- Begin the hash table with an @ sign.
- Enclose the hash table in braces {}
- Enter one or more key-value pairs for the content of the hash table.
- Use an equal sign (=) to separate each key from its value.

---
### Using Get-WinEvent

##### Simple Usage

To list the available logs, we can use the `-ListLog` flag.
```powershell
Get-WinEvent -ListLog *
Get-winEvent -ListLog *ssh*
```
- Specifying a `*` at the end retrieves all logs without any filtering applied.
- The `*` is also a wildcard, and can be used to look for specific logs.

To specify a set of columns to show, and format the output as a table, we can use the following:
```powershell
Get-WinEvent -ListLog * | Select-Object LogName, RecordCount, IsClassicLog, IsEnabled, LogMode, LogType | Format-Table -AutoSize
```

To specify the provider for the logs we can use the `-ListProvider` flag.
```powershell
Get-WinEvent -ListProvider * | Format-Table -AutoSize
```

To retrieve events from the System log:
```powershell
Get-WinEvent -LogName 'System' -MaxEvents 50 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```

To retrieve events from **Microsoft-Windows-WinRM/Operational**:
```powershell
Get-WinEvent -LogName 'Microsoft-Windows-WinRM/Operational' -MaxEvents 30 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```

> Can use the `-Oldest` flag to obtain the oldest events instead of manually sorting.

To retrieve events from a `.evtx` file, we need to specify the path:
```powershell
Get-WinEvent -Path 'C:\Tools\chainsaw\EVTX-ATTACK-SAMPLES\Execution\exec_sysmon_1_lolbin_pcalua.evtx' -MaxEvents 5 | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```

##### Parsing `EventData`

###### Using `Properties`
This outputs all of the data found in a singular event record
```powershell
Get-WinEvent -Path C:\filepath.evtx -FilterXPath "*/System/EventID = 1" | Select-Object -Property *
```
- The `-Property *` parameter, when used with `Select-Object`, instructs the command to select all properties of the objects passed to it.
- It outputs the content of `EventData` in field called `Properties` with several arrays.

To output all of the content of `EventData` values in the `Properties` array:
```powershell
Get-WinEvent -Path C:\filepath.evtx -FilterXPath "*/System/EventID = 1" | Select-Object -ExpandProperty Properties
```
- This will print all of the *values only* found in the `EventData`.
- Using the `XML` option, [[#Using `XML`|Using XML]], we can see both field name and value. 

To get the content of a singular field, we have to know its index.
```powershell
Get-WinEvent -Path C:\filename.evtx -FilterXPath "*/System/EventID = 1" |
ForEach-Object {
    $_.Properties[4].Value
}
```
- The `$_` is a variable for and entire log.
- It then takes the `Properties` array and gets the content of the 5th element with index 4, which is the `Image` field.
###### Using `XML`
To output the content of the `EventData` with both field and value, we can convert the entire event into [[XML]] format, and then parse down to the individual data fields themselves:
```powershell
Get-WinEvent -Path C:\filepath.evtx |
ForEach-Object {
    [xml]$xml = $_.ToXml()
    $xml.Event.EventData.Data | ForEach-Object {
        "$($_.Name) : $($_.'#text')"
    }
    "`n`n`n"
}
```
- This takes the entire event row `$_`, then converts it to `XML`.
- Then, it drills down into the singular `Data` element, and for each object, it outputs the name and the value.
	- This is made visible in Event Viewer application in the Details section of a log and going into the XML view.
- The `.Name` is the `Name` attribute of the `XML` data, so it is the name of the singular data item.
- The `#text` gets the textual value between the `XML` tags.

To output only a singular data value from the entire `EventData`, we can do the following:
```powershell
Get-WinEvent -Path C:\filepath.evtx |
ForEach-Object {
    [xml]$xml = $_.ToXml()
    $xml.Event.EventData.Data |
	Where-Object {$_.Name -eq "Image"} |
	Select-Object -ExpandProperty '#text'
}
```
- This selects the `Image` value.

To be able to differentiate between the output images, we can add the timestamp for each log:
```powershell
Get-WinEvent -Path C:\filepath.evtx |
ForEach-Object {
    [xml]$xml = $_.ToXml()
    $utcTime = $xml.Event.EventData.Data | Where-Object { $_.Name -eq "UtcTime" } | Select-Object -ExpandProperty '#text'
    $image   = $xml.Event.EventData.Data | Where-Object { $_.Name -eq "Image" }   | Select-Object -ExpandProperty '#text'

    Write-Output "UtcTime : $utcTime"
    Write-Output "Image   : $image"
    "`n"
}
```

##### Using XPath

Filtering events with *FilterXPath*. 
- To use XPath queries with `Get-WinEvent`, we need to use the `-FilterXPath` parameter. This allows us to craft an XPath query to filter the event logs.
```powershell
Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' -FilterXPath "*[EventData[Data[@Name='Image']='C:\Windows\System32\reg.exe']] and *[EventData[Data[@Name='CommandLine']='`"C:\Windows\system32\reg.exe`" ADD HKCU\Software\Sysinternals /v EulaAccepted /t REG_DWORD /d 1 /f']]" | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```

Suppose we want to investigate any network connections to a particular suspicious [IP] address (`52.113.194.132`) that [[Sysmon]] has logged.
```powershell
Get-WinEvent -LogName 'Microsoft-Windows-Sysmon/Operational' -FilterXPath "*[System[EventID=3] and EventData[Data[@Name='DestinationIp']='52.113.194.132']]"
```

##### Using Hash Table

To filter *windows events*, the `-FilterHashtable` flag can be used to define conditions:
```powershell
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1,3} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```
- This obtains events with IDs 1 and 3.

Another example given a path for the log file, and looking for *DLL hijack* attacks.
```powershell
 Get-WinEvent -FilterHashtable @{Path="C:\Logs\DLLHijack\*"; ID=7} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Where-Object {$_.Message -match ‘Signed: false’} | ForEach-Object {Write-Host $_.Message `n}
```
- ID of 7 for image load.
- Outputs the needed columns and checks if the content contains `Signed: false`.

To look for a certain library that is being loaded:
```powershell
Get-WinEvent -FilterHashtable @{Path='C:\Logs\PowershellExec\*'; Id=7} | Select-Object TimeCreated, Id, Message | Where-Object {$_.Message -match 'ImageLoaded:\s+C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\clr.dll'} | Format-List
```
- Used to detect unmanaged PowerShell code. 
- The presence of "Microsoft .NET Runtime...", `clr.dll`, and `clrjit.dll`

To check for process access:
```powershell
Get-WinEvent -FilterHashtable @{Path='C:\Logs\Dump\*'; Id=10} | Select-Object TimeCreated, Id, Message | Where-Object {$_.Message -match 'TargetImage:\s+C:\\Windows\\system32\\lsass.exe' -and $_.Message -notmatch 'SourceImage:\s+C:\\Windows\\system32\\svchost.exe'} | Format-List
```
- here we check that the image that is loaded is `lsass`, and that the image loading it is not `svchost`.

To get logs based on certain dates, we can create date variables:
```powershell
$startDate = (Get-Date -Year 2023 -Month 5 -Day 28).Date
$endDate   = (Get-Date -Year 2023 -Month 6 -Day 3).Date

Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Sysmon/Operational'; ID=1,3; StartTime=$startDate; EndTime=$endDate} | Select-Object TimeCreated, ID, ProviderName, LevelDisplayName, Message | Format-Table -AutoSize
```

---


