### General Notes

Registers are small storage locations used by the CPU for storage.
- The CPU accesses data from the registers quicker than any other storage medium.

Registers are divided into 4 main types:
- *Instruction Pointer/Program Counter*: Contains the address of the next instruction to be executed by the CPU. For 16 bit processors, it's called the **IP**, and for 32 bit processors it's called the **EIP**, and for 64 bit processors it's called the **RIP**. 
- *General Purpose Registers*: These are general purpose and can hold integers, pointers, and other values.
- *Status Flags Register*: This is a single register that contains many single bit flags that can either be 0 or 1. 
- *Segment Registers*: These are 16 bit registers that divide the memory into logical chunks to facilitate memory access and addressing.

---
#### General Purpose Registers

These are registers that are used for temporary storage for data that is being actively used.
- These registers have different naming conventions based on the bit mode of the system.
	- For 16 bit systems, the registers are `AX, BX, CX, DX, SI, DI, BP, SP`. Explained below.
	- For 32 bit systems, the registers start with `E` for *extended*.
	- For 64 bit systems, the registers start with `R` for *register*.

Moreover, to access certain parts of the registers, sub-registers are used:
- **RAX** -> all 64 bits of the register.
- **EAX** -> low 32 bits of RAX
- **AX** -> low 16 bits of RAX
- **AL** -> low 8 bits of RAX. Doesn't exist for all registers, only for `AX, BX, CX, DX`
- **AH** -> high 8 bits of AX. Doesn't exist for all registers, only for `AX, BX, CX, DX`

> In 64 bit mode, writing to `EAX` clears the upper 32 bits of the 64 bit register, `RAX`.

The use of these registers is explained below. Note, these uses are historical and they can change:
- `AX` - **Accumulator Register** : This registers stores the results of arithmetic operations. It is also used as the return value register, or for temporary scratch.
- `BX` - **Base Register** : This register is used as a base pointer to store the base address when using an offset.
- `CX` - **Counter Register** : This register is used in counting operations such as loops.
- `DX` - **Data Register** : This register is used in multiplication and division operations.
- `SP` - **Stack Pointer Register**: This register points to the top of the stack and changes with the operations `push`, `pop`, `call`, `ret`, `sub`, ...
- `BP` - **Base Pointer Register**: This is used to access parameters, local variables, and arguments passed in the stack.
- `RSI/RDI` - **Source/Destination Index Register**: These are used with string operations.

There are also the `R8 - R15` registers which were added in 64 bit systems to provide more registers to be used. The naming convention used:
- `R8` -> all 64 bits
- `R8D` -> lower 32 bits. D for double word.
- `R8W` -> lower 16 bits. W for word.
- `R8B` -> lower 8 bits. B for byte.

#### Status Flags Register

| Flag             | Abbreviation | Explanation                                                                                                                                       |
| ---------------- | ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| Carry            | CF           | Set when a carry-out or borrow is required from the most significant bit in an arithmetic operation. Also used for bit-wise shifting operations.  |
| Parity           | PF           | Set if the least significant byte of the result contains an even number of 1 bits.                                                                |
| Auxiliary        | AF           | Set if a carry-out or borrow is required from bit 3 to bit 4 in an arithmetic operation (BCD arithmetic).                                         |
| Zero             | ZF           | Set if the result of the operation is zero.                                                                                                       |
| Sign             | SF           | Set if the result of the operation is negative (i.e., the most significant bit is 1).                                                             |
| Overflow         | OF           | Set if there's a signed arithmetic overflow (e.g., adding two positive numbers and getting a negative result or vice versa).                      |
| Direction        | DF           | Determines the direction for string processing instructions. If DF=0, the string is processed forward; if DF=1, the string is processed backward. |
| Interrupt Enable | IF           | If set (1), it enables maskable hardware interrupts. If cleared (0), interrupts are disabled.                                                     |
#### Segment Registers

The segment registers used are:
- `CS` - **Code Segment**: Points to the code section in the memory.
- `DS` - **Data Segment**: Points to the program's data section in the memory.
- `SS` - **Stack Segment**: Points to the program's stack in the memory.
- `ES, FS, GS` - **Extra Segments**: These and the `DS` divide the program's memory into 4 sections.

---
### Instructions

Instructions are written and they include the operation and the operands.
- The CPU executes these instructions based on the operation which has an *opcode*.
- The operands that are to be executed on can be registers, immediate constants, or memory locations. Memory locations are placed inside square brackets. The memory can be directly placed as a hex, or by placing the register name in square brackets. The value inside the register is then used as a memory address.

The structure of an instruction:
```
operation destination, source
```
##### General Instructions

The `mov` instruction is used to move data between registers, or between memory and registers.
- Can also operate on constants.
- Memory to memory movement is not allowed.

The `lea` instruction is used to move the address of the source into the destination.
- Not the actual content like the `mov` instruction.

The `nop` instruction is used to consume CPU cycles while waiting for something to go through.
- What actually happens is that it exchanges the value in the `EAX` register with itself.
```
nop
```

##### Branching & Conditionals

`test` instruction is used to perform a bitwise AND on the two operands.
- It sets the `ZF` if the result is 0.

`cmp` instruction compares the two operands.
- `ZF` is set if both operands are equal.
- `CF` is set if source is greater than destination.
- Both `ZF` and `CF` are cleared if destination is greater than source.

`jmp` is used to make the control flow jump to a specific location.
```
jmp location
```

`call` instruction is used to perform a function call.
```
call location
```

| **Instruction** | **Explanation**                                                                                                                                       |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `jz`            | Jump if the ZF is set (ZF=1).                                                                                                                         |
| `jnz`           | Jump if the ZF is not set (ZF=0).                                                                                                                     |
| `je`            | Jump if equal. Often used after a CMP instruction.                                                                                                    |
| `jne`           | Jump if not equal. Often used after a CMP instruction.                                                                                                |
| `jg`            | Jump if the destination is greater than the source operand. Performs signed comparison and is often used after a CMP instruction.                     |
| `jl`            | Jump if the destination is lesser than the source operand. Performs signed comparison and is often used after a CMP instruction.                      |
| `jge`           | Jump if greater than or equal to. Jumps if the destination operand is greater than or equal to the source operand. Similar to the above instructions. |
| `jle`           | Jump if lesser than or equal to. Jumps if the destination operand is lesser than or equal to the source operand. Similar to the above instructions.   |
| `ja`            | Jump if above. Similar to jg, but performs an unsigned comparison.                                                                                    |
| `jb`            | Jump if below. Similar to jl, but performs an unsigned comparison.                                                                                    |
| `jae`           | Jump if above or equal to. Similar to the above instructions.                                                                                         |
| `jbe`           | Jump if below or equal to. Similar to the above instructions.                                                                                         |

---
