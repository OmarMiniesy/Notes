### General Notes

When [[Malware]] is analyzed without being executed, this is called *static analysis*.
- The properties of the executable file are analyzed without actually running the file. Taking a look at the structure, strings, searching for well known signatures, and studying metadata.
- Malware is usually in Portable Executable format, PE. Check [[Portable Executable (PE)]].

Some static analysis techniques include:
- Checking for strings in malware.
- Checking the PE header for information related to different sections.
- Using a disassembler to look at the code.

> A **disassembler** converts the malware's code from binary to assembly so that an analyst can look at the instructions of the malware statically. A **debugger** allows placing break points during the malware execution to view instructions.

To avoid static analysis, malware often use:
- *Obfuscation*: deliberately making code hard to read, understand, or analyze, while keeping the same functionality. This evades signature based detection.
- *Packing*: compressing or encrypting the executable so that the malicious code is not present in plaintext on disk. The malware is restored at runtime in the memory, and run directly.

> This is where [[Dynamic Analysis]] comes in play.

##### Tools

- Dependency Walker
- PeID: used to identify *packed* or *protected* executable files.
- pestudio
- Detect It Easy
- PE Explorer
- PEview
- PE Tree
- ResourceHacker
- IDA Freeware
- WinDbg
- Strings
- [VirusTotal](https://www.virustotal.com/gui/home/upload): Showcases the history, first & last submission, metadata, hashes, behavior, & comments.

---
### Static Analysis Techniques

#### File Type

Determine the file type:
```bash
file <file-name>
```

Can also check for the header of the file by viewing the hex bytes using `hexdump`
```bash
hexdump <file-name>
```
- Check the magic numbers to identify the file type and reference with this [list](https://en.wikipedia.org/wiki/List_of_file_signatures).

#### Malware Fingerprinting

Create a unique identifier for the malware using cryptographic hashes like MD5, SHA256. This is used to:
- Identify and track the malware
- Scan a system for the presence of any identical malware
- Confirmation of previous encounters
- Share the IOC with *Threat Intelligence*.

```bash
md5sum <file-name>
sha256sum <file-name>
```

> This can then be used to identify the malware on [Virus Total](https://www.virustotal.com/gui/home/search).

#### Import Hashing (IMPHASH)

This hash is calculated from the import functions of a *PE* file.
- It operates by converting all imported function names to lowercase and then fusing all the names together in a single string arranged in alphabetic order.
- An MD5 hash is then generated for the result string.

Can use the following code to obtain the IMPHASH of a file using Python:
```python
## imphash_calc.py

import sys
import pefile
import peutils

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)
imphash = pe.get_imphash()

print(imphash)
```

Then running the following command to obtain the IMPHASH of a file:
```bash
python3 imphash_calc.py <file-name>
```

#### Fuzzy Hashing (SSDEEP)

Hashing technique to compute the content similarity between files by dissecting files into smaller fixed size blocks and calculating the hash for each block.
- The resulting hashes are consolidated to generate the final hash.
- It allocates more weight to longer sequences of common blocks making it effective at identifying minor modifications between files.

The `ssdeep` command can be used to check the SSDEEP hash of a file.
```bash
ssdeep <file-name>
```

Can run `ssdeep` in a directory to find matches between files in that directory using the flags `-pb`.
```bash
ssdeep -pb *
```
- The number in between brackets shows the similarity percentage between the files.
- `-p` for pretty matching mode.
- `-b` to display only the file names.

#### Section Hashing (*PE* Sections)

This is used to identify sections of a *PE* file that have been modified to identify minor variations in malware samples.
- Hash is calculated by calculating the hash of each section and comparing the same sections in different files.
- This means that parts of the PE files that have been tampered can be identified.

This Python code can be used to calculate the section hashes of a file:
```python
## section_hashing.py

import sys
import pefile

pe_file = sys.argv[1]
pe = pefile.PE(pe_file)

for section in pe.sections:
    print (section.Name, "MD5 hash:", section.get_hash_md5())
    print (section.Name, "SHA256 hash:", section.get_hash_sha256())
```

Then run the command below:
```python
python3 section_hashing.py <file-name>
```

> Malware authors can obfuscate section names or use other names to bypass this type of check.

#### Strings Analysis

To list the strings present in a file to understand what the malware does, who it contacts, and so on:
```bash
strings <file-name>
```
- Sometimes the output is too much, so we can redirect to file and view the file.

To specify printing strings of a minimum length, we can specify it using the `-n` flag.
```bash
strings -n 15 <file-name>
```

#### Unpacking Malware

*Packing* is an obfuscation technique to:
- Make it challenging to figure out the structure or functionality
- It reduces the size of the file
- Hinders normal reverse engineering
- Impacts string analysis because string references are obscured.
- Replaces conventional *PE* sections with a compact loader stub which retrieves code from a compressed data section.

To unpack `UPX` packed files:
```bash
upx -d -o <unpacked_file_name> <packed_file_name>
```

Determine the [[Portable Executable (PE)]] file *Imports* & *Exports* to understand behavior of malware.
- Can be done using tools like `x64dbg` in the *Symbols* tab.

---
