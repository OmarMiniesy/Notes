
#### General Stuff

> computer system organized in layers. Layered architecture is good because each layer shields details, allows evolving of a ceratin layer, and to achieve a certain goal or function. 

> machine language defines the architecture

> 85% of computer usage is created and used through the operating system.

> Some parts of the OS are not running at all times to allocate resources. 

> BIOS checks the hardware components on startup
> It then downloads the bootloader. The bootloader is downloaded based on charactersisitcs of each component. 
> Once the OS needed is decided, the kernel is then loaded for that OS into the memory.
> That kernel is then started so then the OS starts.

> system calls can be conducted in a synchronous(blocking) manner OR asynchronous(non-blocking). 

---

#### P. 5-7

> OS objectives and definition in slides
> the os is a software that controls the common functions and allocates the resources.
> the os is the one program running at all times(kernel)

> kernel is part of the OS that is running at all times, the most used functionalities being used.
> can be static or dynamic to grow and shrink 

> middleware are a part of the OS that provide additional services to developers

```
summary, for our purposes, the operating system includes the always running kernel, middleware frameworks that ease application development and provide features, and system programs that aid in managing the system while it is running
```

---
#### P.7

> A device controller is in charge of a specific type of device. The driver maintains local buffer storage and a set of registers. Responsible for moving data between peripheral devices and local buffer storage for that device.

> A device driver is present for each controller that gives the OS with a uniform method to interface with that device

---
#### P. 8-10

> all controllers can access the data bus which is bad, leading to data scrambling
> the bus has a protocol called bus master that the contollers decide about which happens during a data collision

> Parallel operating devices to notify cpu can use interrupt driven operation

>after fetch execute cycle, check for interrupts
>the interrupt controller chip specificies interrupt priorities

> PSW -> flag register

>interrupt vector starts at address 0 and every slot holds the address of the interrupt, accessible using offset. The pc then changes and becomes the value of that interrupt address.
>the interrupt vector shouldnt be accessible, must be protected

> Then resume operation of the interrupted operation by popping that pc from the stack

---
#### P. 23 -24

> use multiprogramming to reduce idle/wait time and increase utilization of the processor
> happens by running more than one application in parallel, each job(application) has its own dedicated address space.

> timesharing is quickly shifting between one app and another to make the user sense all applications are running at the same time
>swapping process.
> virtual memory to run processes whoese memory usage is larger than the physical memory

---
