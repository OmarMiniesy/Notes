
### General Notes

> Allows an attacker to induce a user to perform actions that they don't intend to perform.
> Attackers personate other users.
> Allows attackers to bypass the [[Same Origin Policy (SOP)]].
> Could allow for full account take over.

> CSRF vulnerabilities occur when vulnerable web apps simply trust the cookies sent by web browsers without further validation.

---

### How it Works

1. 
> There must be a **relevant action** that the attacker has a reason to induce
1. A privileged action such as modifying permissions.
2. An action on user specific data, such as changing password or email.

2. 
> There must be **[[Sessions]] that are handled via [[Cookies]]**.
> This attack involves invoking multiple [[HTTP]] requests, and the application tracks which user invokes through these cookies and sessions.
> ***No other*** mechanism in place for tracking users.

3. 
> There must be **no unpredictable parameters**.
> The attacker should be able to guess and have all parameters found in the requests.

4. 
> HTML code is then used to construct a page from the request that simulates this relevant action.
> For instance, this code is used to change the email address of a user if this is the request.

```
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 30 
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE 

email=wiener@normal-user.com
```

```HTMl
<html> 
	<body> 
		<form action="https://vulnerable-website.com/email/change" method="POST"> 
			<input type="hidden" name="email" value="pwned@evil-user.net" /> 
		</form> 
		<script> document.forms[0].submit(); </script> 
	</body> 
</html>
```
> The `action` attribute of the `form` element is the URL and the path found in the request of the chosen action, and the `method` attribute is `POST` similar to the request.
> The `email` is a parameter, so it is the `input` element, and the `value` attribute holds the new email we want to change to.

> If the request was a `GET` request with the email parameter placed as a query parameter, the exploit wouldn't need to be a different HTML page.
> The payload will be a link that is self-contained, meaning it doesn't open another page.
```html
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net" >
```

5. 
> Once these conditions are in place, and the HTML page is constructed, the user needs to click on a link to open such HTML page.
1.  The attacker's page will trigger an [[HTTP]] request as in the `form` element.
2.  If the user is logged into the main vulnerable webpage, the session cookie will be set.
3.  The webpage will process this request in a nor mal way, and the functionality(action) will be complete, changing the email address.

6. 
> To deliver such an exploit to the user, it can either be opened via a link as stated, similar to reflected [[Cross Site Scripting (XSS)]] attacks.
> These links can be placed in comments, emails, or messages.

---

### CSRF Defences

##### 1. CSRF Token Validation

> Unique, secret, and unpredictable value generated by server and given to the client.
> CSRF tokens must be included when performing sensitive actions.
> Makes it hard for attackers to construct requests in behalf of victims.

##### 2. [[SameSite]] Cookies

> Broswer security mechanism that identifies [[Cookies]] in requests and determines if they are coming from the same website or not.
> To perform sensitive actions, session cookies are required, and SameSite restrictions prevent attackers from triggering such actions across different sites. [[SameSite#What is a Site ?]].
> `Lax` SameSite restrictions.

##### 3. Referer-Based Validation

> Some applications use the `Referer` [[HTTP]] header to defend against CSRF by verifying the request comes from the app's domain.

---

### 1. Bypassing Token Validation

> The token is included as a hidden parameter both in the request, and in the HTML form.

###### Validation of CSRF token depends on request method
> Some applications dont verify the token for `GET` requests.
> Changing the request type in [[Burp Suite]] can skip the validation of the token.
> Test by changing its value for the different requests and how the applications responds.

###### Validation of CSRF token depends on token being present
> If the token is not present, the validation is skipped.
> Removing the entire parameter of the token can bypass the validation,

###### CSRF token not tied to user [[Sessions]]
> Some applications don't validate that the token belongs to the same user session making the request.
> There is a pool of tokens, and any of them if requested works.
> Can exploit this by using the attackers own token and using it for any attack or request.
> If the tokens are single-use, then use [[Burp Suite]] proxy to get the token, but then drop the request so that it doesn't get used. Use the copied token.

###### CSRF token tied to non-session [[Cookies]]
> Some applications tie the CSRF token to a different cookie than the session cookie.
> This happens when applications have 2 frameworks; one for sessions and the other for CSRF protection.
> If the attacker can modify cookie values for other users, then attacks are possible. [[Cookies#Modifying Cookies for CSRF]].
> The attacker can obtain a valid csrf token and cookie from his account, and then use that combination to feed the cookie and token into the victim's browser in the attack.

###### CSRF token is duplicated in a cookie
> Some applications don't maintain on the server a record of the token.
> They duplicate each token within a cookie, and for validation, check that the cookie matches the token.
> If there is any cookie modification/setting available - [[Cookies#Modifying Cookies for CSRF]] - , they obtain a token and put the token into the cookie as well.
> They then feed this cookie and token into the victim browser through the CSRF attack.

###### CSRF token generation is simple
> Try and check if the token is generated using a simple technique, like `md5(username)`, `sha1(username)`, `md5(current date + username)` etc..
> If there is a match, then the token is not unique and can be easily forged.


---

### 2. Bypassing [[SameSite]] [[Cookies]]

> The cookies involved here could be the session cookie which needs to be communicated between the request and browser in the CSRF attack.
> We need to ensure that this session cookie is readable from our CSRF request, which is why we bypass the SameSite restrictions.

###### Bypassing `Lax` using `GET` requests

> Eliciting a `GET` request from the victim browser can create a CSRF attack.
> The request must involve a top-level navigation, a `GET` request.

``` HTML
<script> 
	document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000'; 
</script>
```

> If `GET` requests aren't allowed, override the specified request method type using the parameter `_method` in forms.
> This takes precedence over the normal method.

```HTMl
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
	<input type="hidden" name="_method" value="GET"> 
	<input type="hidden" name="recipient" value="hacker"> 
	<input type="hidden" name="amount" value="1000000">
</form>
```

> The first payload is a normal URL, this issues a `GET` request with the parameters as query parameters.
> The second payload is a form that uses the `POST` method, but we override to `GET` and pass the parameters as inputs.

> This can also be done in the opposite sense.
> Sending a `GET` request, but setting the `_method` parameter to `POST`.
> This can be done if we want to send a `GET` request, but it must be `POST`.

```HTMl
<script> 
	document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000&_method=POST'; 
</script>
```

###### Bypassing [[SameSite]] using on-site gadgets

> For the `SameSite=Strict` cookie, it can be bypassed if a gadget is found that results in secondary requests within the same site.[[SameSite#What is a Site ?]].

> A gadget could be a *client-side* redirect that constructs the redirect target using user input like URL parameters.
> These aren't redirects for the browser, they are seen as normal, same-site requests.
> Therefore, the cookies will be included for any cross-site request.

> Manipulating the gadget to issue this secondary request can enable us to bypass the `Strict` restrictions.
> Server-side requests have the restrictions applied on them, ths works for client-side requests.

> After finding the gadget and bypassing the restriction, the payload will look something like this.
```HTML
<script> 
	document.location = "URL"
</script>
```

###### Bypassing [[SameSite]] `Lax` with newly issued [[Cookies]]

> If the `SameSite` attribute isn't set when a cookie is created by default, Chrome applies `Lax` by default after 2 mins on top-level `POST` requests.
> For 2 minutes, CSRF attacks are possible. Present on OAUTH mechanisms.
> This is only for those where `SameSite` isn't set by defualt.

> Finding a gadget on the same site that enables the victim to be issued a new cookie can allow for refreshing the cookie, giving us time to do the attack.
> To trigger the cookie refresh without having the user login again, we use top-level navigation, and ensure the same cookies of the same session are included.
> Moreover, we need to redirect the user back to our CSRF site to launch the attack.

> Another way to refresh the cookies is from a new tab so browser doesn't leave the page before the attack. This tab redirects to the login page.
> Browsers block pop up tabs, so we need to force the new tab to open.
> Do that by wrapping the pop-up in an `onclick` event.

```HTML
<script>
window.onclick = () => { 
	window.open('https://vulnerable-website.com/login/sso'); 
}
</script>
```

----

### 3. Bypassing Referer-Based Defenses

> The `Referer` [[HTTP]] header is used to verify where the request is originating from.
> Least effective technique.

###### Validation of `Referer` header depends on presence

> Applications verify it when it is present, but if it is not there it is not validated.
> Craft a CSRF payload to drop the `Referer` header can then be used.

```HTML
<meta name="referrer" content="never">
<meta name="referrer" content="no-refferer">
```
>Both work.

###### Circumventing the `Referer` header

> Some applications validate the `Referer` header in a naive way that can be bypassed. For example, if the application validates that the domain in the `Referer` starts with the expected value, then the attacker can place this as a subdomain of their own domain:

```
http://vulnerable-website.com.attacker-website.com/csrf-attack
```

> Likewise, if the application simply validates that the `Referer` contains its own domain name, then the attacker can place the required value elsewhere in the URL:

```
http://attacker-website.com/csrf-attack?vulnerable-website.com
```

> Many browsers now strip the query string from the Referer header by default as a security measure. To override this behavior and ensure that the full URL is included in the request add this header.
```HTML
Referrer-Policy: unsafe-url
```

---

### Preventing CSRF Attacks

> Using CSRF Tokens
* Unpredictable with high randomness. Use a cryptographically secure pseudo-random number generator (CSPRNG), seeded with the timestamp when it was created plus a static secret.
* Tied to the user session.
* Validated in every step while the relevant action works.

> The CSRF tokens should be treated as secrets, examples: 
* In an HTML form as a hidden field.
* Placed as early as possible in the document.
* Placed as a query string in the URL but is less safe.
	* Logged in various locations
	* Liable to be trasnmitted to 3rd parties within the HTTP referer header.
	* can be seen on the user screen.
* Placed in custom request header, since custom requests aren't allowed to be transmitted cross-domain.

> CSRF tokens should be validated by storing them server-side in the user's session data.
> Any request that requires validation should be verified with the token present in the user's session.
> This request should be disregarded if the token is not contained, or is invalid.

> SameSite restrictions should be implemented for every cookie used.
> Use `Strict` by default.

> SameSite doesn't protect against cross-origin same-site attacks.
> Insecure content should be isolated on a separate site.

---
