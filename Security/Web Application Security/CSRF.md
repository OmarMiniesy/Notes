
### General Notes

> Cross-Site Request Forgery.

> Allows an attacker to induce a user to perform actions that they don't intend to perform.
> Allows attackers to bypass the [[Same Origin Policy (SOP)]].

> Could allow for full account take over.

---

### How it Works

1. 
> There must be a **relevant action** that the attacker has a reason to induce
1. A privileged action such as modifying permissions.
2. An action on user specific data, such as changing password or email.

2. 
> There must be **[[Sessions]] that are handled via [[Cookies]]**.
> This attack involves invoking multiple [[HTTP]] requests, and the application tracks which user invokes through these cookies and sessions.
> ***No other*** mechanism in place for tracking users.

3. 
> There must be **no unpredictable parameters**.
> The attacker should be able to guess and have all parameters found in the requests.

4. 
> HTML code is then used to construct a page from the request that simulates this relevant action.
> For instance, this code is used to change the email address of a user if this is the request.

```
POST /email/change HTTP/1.1 
Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 30 
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE 

email=wiener@normal-user.com
```

```HTMl
<html> 
	<body> 
		<form action="https://vulnerable-website.com/email/change" method="POST"> 
			<input type="hidden" name="email" value="pwned@evil-user.net" /> 
		</form> 
		<script> document.forms[0].submit(); </script> 
	</body> 
</html>
```
> The `action` attribute of the `form` element is the URL and the path found in the request of the chosen action, and the `method` attribute is `POST` similar to the request.
> The `email` is a parameter, so it is the `input` element, and the `value` attribute holds the new email we want to change to.

> If the request was a `GET` request with the email parameter placed as a query parameter, the exploit wouldn't need to be a different HTML page.
> The payload will be a link that is self-contained, meaning it doesn't open another page.
```html
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net" >
```

5. 
> Once these conditions are in place, and the HTML page is constructed, the user needs to click on a link to open such HTML page.
1.  The attacker's page will trigger an [[HTTP]] request as in the `form` element.
2.  If the user is logged into the main vulnerable webpage, the session cookie will be set.
3.  The webpage will process this request in a nor mal way, and the functionality(action) will be complete, changing the email address.

6. 
> To deliver such an exploit to the user, it can either be opened via a link as stated, similar to reflected [[Cross Site Scripting (XSS)]] attacks.
> These links can be placed in comments, emails, or messages.

---

### CSRF Defences

##### 1. CSRF Token Validation

> Unique, secret, and unpredictable value generated by server and given to the client.
> CSRF tokens must be included when performing sensitive actions.
> Makes it hard for attackers to construct requests in behalf of victims.

##### 2. SameSite Cookies

> Broswer security mechanism that identifies [[Cookies]] in requests and determines if they are coming from the same website or not.
> To perform sensitive actions, session cookies are required, and SameSite restrictions prevent attackers from triggering such actions across different sites.
> `Lax` SameSite restrictions.

##### 3. Referer-Based Validation

> Some applications use the `Referer` [[HTTP]] header to defend against CSRF by verifying the request comes from the app's domain.

---

### Bypassing Token Validation

> The token is included as a hidden parameter both in the request, and in the HTML form.

###### Validation of CSRF token depends on request method
> Some applications dont verify the token for `GET` requests.
> Changing the request type in [[Burp Suite]] can skip the validation of the token.
> Test by changing its value for the different requests and how the applications responds.

###### Validation of CSRF token depends on token being present
> If the token is not present, the validation is skipped.
> Removing the entire parameter of the token can bypass the validation,

###### CSRF token not tied to user [[Sessions]]
> Some applications don't validate that the token belongs to the same user session making the request.
> There is a pool of tokens, and any of them if requested works.
> Can exploit this by using the attackers own token and using it for any attack or request.
> If the tokens are single-use, then use [[Burp Suite]] proxy to get the token, but then drop the request so that it doesn't get used. Use the copied token.

###### CSRF token tied to non-session [[Cookies]]
> Some applications tie the CSRF token to a different cookie than the session cookie.
> This happens when applications have 2 frameworks; one for sessions and the other for CSRF protection.
> If the attacker can modify cookie values for other users, then attacks are possible. [[Cookies#Modifying Cookies for CSRF]].
> The attacker can obtain a valid csrf token and cookie from his account, and then use that combination to feed the cookie and token into the victim's browser in the attack.

###### CSRF token is duplicated in a cookie
> Some applications don't maintain on the server a record of the token.
> They duplicate each token within a cookie, and for validation, check that the cookie matches the token.
> If there is any cookie modification/setting available - [[Cookies#Modifying Cookies for CSRF]] - , they obtain a token and put the token into the cookie as well.
> They then feed this cookie and token into the victim browser through the CSRF attack.

---
