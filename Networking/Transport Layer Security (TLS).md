### General Notes

This is a [[Protocol]] that ensures privacy between communicating applications on the internet.
- These communicating parties are usually a client, and the server on the internet.

> It is the successor to SSL (Secure Socket Layer).

- It provides [[Encryption]] for data being transmitted over a network ensures its **confidentiality**.
- It provides **authentication** by verification of the server through the use of [[Certificates]]. *The client is not verified*.
- It provides **integrity** through [[Message Authentication]] codes (hashing) to ensure that data sent isn't corrupted.

> TLS uses [[Transport Layer#TCP]] for data transmission.

TLS operates between the [[Transport Layer]] and the *application layer*, therefore, it can provide security for any layer above the Transport Layer.
- Such as [[HTTP]] (became [[HTTPS]]), [[File Transfer Protocol (FTP)]], SMTP, or [[Virtual Private Network (VPN)]] connections.

TLS operates by first performing a **handshake** process between the server and client during which symmetric keys are exchanged using a process like [[Diffie-Hellman]] or [[RSA]] to start an asymmetric encryption session.
- TLS also uses a **Record Layer** which is responsible for the actual encryption and decryption processes, as well as data management.
- [[Certificates]] are also sent by the server to provide authentication.


> The **Record Layer** provides abstraction to the application layer using TLS. The application layer simply transmits data normally, but the record layer is responsible to securely handle it.

---
### TLS Handshake (TLS 1.2)

The following illustrates the handshake between client and server to start a session of secure communication.

1. Since TLS operates over TCP, a TCP connection must first be established. A TCP handshake takes place between client and server first.
2. **Client Hello**: The client sends a `hello` message to the server. It includes a random number $R_B$ and the list of [[Encryption]] [[Protocol]]s that it supports.
3. **Server Hello**: The server responds with a `hello` message to the client. It includes a random number $R_S$ as well as the chosen encryption protocol from the ones sent by the client. This message also includes the servers certificate which contains a copy of the server's public key all signed by a Certificate Authority(CA).

The client now verifies the signature of the certificate using the CAs public key.
- On verification, the public key of the server is now assumed to be legitimate and is used in the handshake from now on.

> The server must have a public and private key pair in order to continue the handshake and verification process. As known, the private key is kept a secret only known by the server. If it is compromised, then so is the server.

Using randomly generated numbers, $R_B$ and $R_S$ prevents replay attacks between different connections. This is because every time a new connection is made, new random numbers are generated creating a new symmetric key.
- If the same random numbers are used, the same keys will be generated, which isn't the case.

> To protect against replay attacks within the same connection, TLS includes counters and timestamps to fight that.

Now, we have only managed to exchange the hello messages, and the client has the server's certificate and its public key.
- All of this information can be forged by an attacker, therefore, until now, the client has no way of actually confirming the identity of the server.

To ensure confidentiality and install end-end encryption between client and server, a **Premaster Secret (PS)** is needed to be able to derive the symmetric keys.
- The $PS$ is known only by client and server.
- Can be generated by [[RSA]] or [[Diffie-Hellman]].

4. **Client sends PS - RSA**: The client generates a random $PS$ and encrypts it with the server public key and sends it to the server. This way, only the legitimate server can decrypt this $PS$ using its private key.
- OR
4. **PS Creation - Diffie-Hellman**: This follows the Diffie-Hellman protocol by sharing public parameters and then deriving the $PS$ from them. The public parameters being sent by the server are digitally signed using its private key, which are verified by the client using the public key it received with the certificate.

> **Forward Secrecy**, which is securing all the messages in the past if an attacker manages to compromise a message in the future is only available using the Diffie Hellman approach and not using RSA. If the attacker manages to obtain the server private key, then the $PS$  can be derived using the RSA approach. However, the attacker will not be able to compute the Diffie Hellman parameters due to the mathematical complexity.

The client and server now have 3 pieces of information, $R_B$, $R_S$, and $PS$. These can be used to derive the symmetric keys that are *known by both parties*.
- Encryption key and Integrity key for client: $C_B$ and $I_B$.
- Encryption key and Integrity Key for server: $C_S$ and $I_S$.

5. The final step is to verify [[Message Authentication]] by sending MACs (message authentication codes) over all the messages communicated until now. This is to ensure that none of the messages sent between client and server were tampered with.

Once this step is complete, the handshake is complete, and now all messages communicated between the two are secure.
- Messages are encrypted and have their MACs calculated using the sender's keys.
- End-to-end encryption is now complete.

---
